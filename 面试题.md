# 计算机网络



1. 计网5层模型和7层模型 

2. 应用层协议有什么 

3. 输入网址发送请求到接受响应的过程 

4. 网络拥堵可能有什么原因 

5. TCP拥塞避免[算法]() 

6. 延迟ACK了解么？

7.  ipv6和ipv4的区别

8. Http https 区别（腾讯） SSL握手过程

   1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

    

   2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

    

   3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

    

   4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
   
   

9. TCP和UDP的区别
10. TCP的可靠传输机制
11. Get和Post 的区别

# 操作系统

## 进程概念

 进程实体的组成：**程序段、数据段、程序控制块（PCB）**

线程组成：TCB

## 面题

1. 进程和线程区别

   

   **根本区别**：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

   **资源开销**：

   ​		进程间切换代价大，线程间切换代价小。每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

   ​		进程拥有资源多，线程拥有资源少

   **包含关系**：一个进程内可以有多个线程，进程是运行中的程序，线程是进程的内部的一个执行序列

   **影响关系**：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

   **内存分配**：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的

   **执行过程**：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行

   

2. 进程和线程的切换上下文

   **进程切换涉及虚拟地址空间的切换而线程不会**，**每个进程都有自己的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间**。

   

3. 上下文是什么？

   **上下文就是内核重新启动一个被抢占的进程所需的状态。**包括一下内容：

   - 寄存器
   - 程序计数器 PC
   - 各种内核数据结构：比如描绘地址空间的页表，包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。

   

4. 线程之间同步的机制 

   ​		**互斥锁**
   ​		**条件变量**
   ​		**读写锁**
   ​		**信号量**

5. 物理地址、虚拟地址和逻辑地址的区别 

   物理地址、虚拟地址、逻辑地址关系

   物理地址是指内存上存储单位的实际地址。

   虚拟地址的理解要结合虚拟内存，虚拟内存空间。虚拟内存空间可能会大于物理内存实际大小（用到了磁盘充当虚拟内存）。

   一般情况下可以把逻辑地址当成虚拟地址

   段式、页式逻辑地址：

   <img src="面试题.assets/clip_image002.png" alt="img" style="zoom: 50%;" /><img src="面试题.assets/clip_image004.png" alt="img" style="zoom:50%;" />

   但是逻辑内存是指程序段内的地址，在多级页表情况下

   <img src="面试题.assets/clip_image006.png" alt="img" style="zoom:50%;" />

   最后两段： 页帧号+offset 才是 “程序段”内的地址。

   

   

6. 为什么要分成物理地址和虚拟地址 

   ​	方便编译器和操作系统安排程序的地址分布。（更好分配碎片空间）

   ​	由于局部性原理，使用虚拟地址可以节省空间，内存只需要加载程序要用的代码和数据。

   ​	保证数据的安全和进的隔离，防止进程访问其他进程或者操作系统在内存中的数据。

   

   ​	虚拟内存作用 详细版

   ​	使用虚拟内存主要是基于以下三个方面考虑，也就是说虚拟内存主要有三个作用：

   ​	作为缓存工具，提高内存利用率：使用 DRAM 当做部分的虚拟地址空间的缓存（虚拟内存就是存储在磁盘上的 N 个连续字节的数组，数组的部分内容会缓存在 DRAM 中）。扩大了内存空间，当发生缺页异常时，将会把内存和磁盘中的数据进行置换。

   ​	作为内存管理工具，简化内存管理：每个进程都有统一的线性地址空间（但实际上在物理内存中可能是间隔、支离破碎的），在内存分配中没有太多限制，每个虚拟页都可以被映射到任何的物理页上。这样也带来一个好处，如果两个进程间有共享的数据，那么直接指向同一个物理页即可。

   ​	作为内存保护工具，隔离地址空间：进程之间不会相互影响；用户程序不能访问内核信息和代码。页表中的每个条目的高位部分是表示权限的位，MMU 可以通过检查这些位来进行权限控制（读、写、执行）。

   

7. 虚拟地址转换为物理地址的过程 （https://blog.csdn.net/qq_41453285/article/details/107827858）

   Linux的四级页表

   <img src="面试题.assets/clip_image006.png" alt="img" style="zoom:50%;" />

   第一步，先将虚拟地址转换为逻辑地址：找到最后一级页表得到 页帧号 + offset 组成逻辑地址
   第二步，再将逻辑地址转换为线型地址：	逻辑地址加上基址获得线性地址
   第三步，再将线型地址再转换为物理地址：

   详细：

   第一步，先将虚拟地址转换为逻辑地址：根据程序中的虚拟地址得出其所在的段（页），然后加上段偏移，我们就能得到一个逻辑地址
   第二步，再将逻辑地址转换为线型地址：有了逻辑地址之后，我们需要将逻辑地址转换为线型地址（因为线型地址是逻辑地址转换到物理地址的一个中间层），只需要把逻辑地址加上段的基地址就能生成一个线型地址
   第三步，再将线型地址再转换为物理地址：
   如果启用了分页机制，那么就需要将需要找到段中对应页的地址，然后再找到页内偏移地址，最后得到物理地址
   如果没有启用分页机制，那么线型地址直接就是物理地址了

   

8. 页式 段式 段页式存储

   页式

   <img src="面试题.assets/image-20210315120305021.png" alt="image-20210315120305021" style="zoom:50%;" />

   页式带快表

   <img src="面试题.assets/image-20210315120406563.png" alt="image-20210315120406563" style="zoom: 67%;" />

   段式存储

   <img src="面试题.assets/image-20210315120435417.png" alt="image-20210315120435417" style="zoom: 67%;" />

   段页式

   <img src="面试题.assets/image-20210315122228373.png" alt="image-20210315122228373" style="zoom: 67%;" />

9. 快表是存储在哪里的

    放在联想存储器（缓冲存储器），具有并行查找的功能。

    

10. 进程的调度策略

11. 死锁的概念、条件、避免





# Java集合框架

## HashMap为什么改为尾插法？

https://www.cnblogs.com/qmillet/p/13054208.html

1.8之前不管是元素的添加，还是数组扩容，只要涉及到 hash 冲突，就会采用头插法将元素添加到链表中，头插法在多线程的情况下会导致死循环。

![img](面试题.assets/1384439-20200606120547060-2090940084.png)

## 为什么HashMap初始化大小为16？

2的整数幂 进行异或运算

**总结： 1 减少hash碰撞**

​       **2 提高map查询效率**

​      **3 分配过小防止频繁扩容**

​      **4 分配过大浪费资源**

# Java 并发

## Volatile变量

# JavaWeb

请求转发和重定向的区别？



Session 和Cookie 的区别?

- **安全性：** Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
- **存取值的类型不同**：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
- **有效期不同：** Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
- **存储大小不同：** 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

# JVM

## 修饰符访问范围

| 访问范围         | private  | friendly(默认) | protected | public |
| ---------------- | -------- | -------------- | --------- | ------ |
| 同一个类         | 可访问   | 可访问         | 可访问    | 可访问 |
| 同一包中的其他类 | 不可访问 | 可访问         | 可访问    | 可访问 |
| 不同包中的子类   | 不可访问 | 不可访问       | 可访问    | 可访问 |
| 不同包中的非子类 | 不可访问 | 不可访问       | 不可访问  | 可访问 |

## 内存区域



## 触发GC 的时机

1. 堆即将满
2. System.gc()；调用系统函数触发

# JAVA

## Java数据类型

java 只有两种数据类型：基本数据类型和引用类型（其实还有null 类型,null类型可以转换为任意引用类型 详细见 https://blog.csdn.net/w605283073/article/details/72896651）

- 基本数据类型有：int.double..
- 引用数据类型：类、接口、数组

（对象分配在堆中，局部变量（引用，基本数据类型）放在栈上。）

## 四种引用

生命力优先级从高到低：强引用，软引用，弱引用，虚引用。

1. 强引用NormalReferemce

   宁愿OOM也不会回收，除非引用置为null

   ~~~java
   Object o = new Object() ;
   ~~~

2. 软引用 SoftReference

   GC时如果内存不足，垃圾回收器就会回收软引用。引用队列用于存放被回收对象的引用

   ~~~java
   Object obj = new Object();
   ReferenceQueue queue = new ReferenceQueue();
   SoftReference softObj = new SoftReference(obj,queue);
   obj = null； //去除强引用
   ~~~

3. 弱引用 WeakReference

   GC时一定会被回收。可以配合引用队列使用

   ~~~java
    Object obj = new Object();
    WeakReference<Object> weakObj = new WeakReference<Object>(obj);
    obj = null； //去除强引用
   ~~~

4. 虚引用 PhantomReference

   任何时候都可能被回收，无法通过虚引用获取对象的任何属性或者方法。相当于一个没功能的引用。必须配合引用队列使用，对应的某个对象被回收之后，虚引用进入引用队列。利用这一点，我们可以通过判断这个队列有没有这个虚引用来判断对应的对象是否被回收了。

   ~~~java
   Object obj = new Object();
   ReferenceQueue queue = new ReferenceQueue();
   PhantomReference<Object> phantomObj = new PhantomReference<Object>(obj , queue);
   obj = null； //去除强引用
   ~~~

   

## 内存泄漏

https://www.jianshu.com/p/54b5da7c6816

内存泄漏的对象包含：1. 不可达的对象（这部分垃圾回收器会自动回收）。2. 对象可达，但是不可用。

![img](面试题.assets/2827798-583e7d9d5047a49c.gif)

- ## 内存泄漏根本原因：长生命周期的对象持有短生命周期对象的引用

例子：

~~~java
Static Vector v = new Vector(10);

for (int i = 0; i < 100; i++) {
    Object o = new Object();
    v.add(o);
    o = null;
}
~~~



## 内存分配策略

## Comparator 和Comparable 区别

1. comparator 是外部比较器，comparable 是内部比较器。
2. comparator 是一种专用比较器，体现了策略模式。





## == 与 equals()区别

1. equals 是方法 == 是操作符

2. 对于基本类型 == 比较的是值，对于引用比较的就是引用存放的地址（对象的地址）

3. equals比较对象是否相等，equals()存在于Object 中，基本类型没有equals方法

   

## hashCode()

默认的hashCode 返回对象的地址。但是hashCode 实际上和地址没啥关系，可以自定义一个hashCode。

## 为什么重写equals()一定要重写hashCode()?

~~~java
 /**
     * Returns a hash code value for the object. This method is
     * supported for the benefit of hash tables such as those provided by
     * {@link java.util.HashMap}.
     * .........
     * <li>If two objects are equal according to the {@code equals(Object)}
     *     method, then calling the {@code hashCode} method on each of
     *     the two objects must produce the same integer result.
     ....... 
  **/
~~~



保存一致性。Object 源码中提到：“hashCode（） 用于HashMap的使用，为了方便用户使用，要尽量保存hashCode和Equals()的一致性。”也就是说相同的对象的hashCode 要保证相同。不同对象的hashCode 可能相同，这个时候要用equals()来判断是否真的相同。（实际上也不是硬性要求，两个方法不一起重写也可以，但是这是个很糟糕的编程习惯）。这里的“相同的对象”指的是调用Equals（）方法返回true 的两个对象。（equals() 和hashCode（）保持一致）。hashCode()不重写时，返回的是对象地址，因此两个对象永远不会相同。

## POJO和JavaBean 区别

https://www.jianshu.com/p/224489dfdec8

两者都是一种类的规范。Pojo比javabean更简洁。

- ## pojo要求：

1. ### private 的属性

2. ### 属性对应getter setter

3. ### 没有实现任何接口，没有任何继承，没有被其他框架侵入的java对象

- ## JavaBean要求：

1. ### 所有属性为private。

2. ### 这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范。

3. ### 这个类必须有一个公共的缺省构造函数。即是提供无参数的构造器。

4. ### 这个类应是可序列化的。实现serializable接口。

- ## 区别

  POJO其实是比javabean更纯净的简单类或接口。POJO严格地遵守简单对象的概念，而一些JavaBean中往往会封装一些简单逻辑。

  POJO主要用于数据的临时传递，它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力。

  Javabean虽然数据的获取与POJO一样，但是javabean当中可以有其它的方法。

  

  

# Mysql--DB

## 事务隔离级别

## 数据库引擎（INNODB ,MYISAM）

## InnoDB底层原理

## 索引

## 索引优化

# REDIS



## 概述

**Redis**是一个高性能的key-value数据库

## 特点

- Redis支持**数据的持久化**，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
- Redis不仅仅支持简单的key-value类型的数据，同时还提供**list，set，zset，hash等数据结构的存储**
- Redis支持**数据的备份**，即master-slave模式的数据备份

## 缓存穿透

穿透形象一点就是：请求过来了 转了一圈 一无所获 就像穿过透明地带一样。key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。

## 穿透解决方案

a.把不存在的key写一下null，这样再来就相当于命中了，其实这种方法局限性很大，今天是5斤龙虾，明天改成6斤的螃蟹，缓存系统和数据库中存储大量无用key本身是无意义的，所以一般不建议。
 b.（布隆过滤器）另外一种思路，转换为查找问题，类似于在海量数据中查找某个key是否存在，考虑空间复杂度和时间复杂度，一般选用布隆过滤器来实现。

布隆过滤器 https://juejin.cn/post/6844904007790673933

## 缓存击穿

缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。（像是小规模的雪崩。）

## 击穿解决方案

1. 在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降
2. 热点数据缓存永远不过期。（访问量特别大的数据就是热点数据，“热门商品”的数据）

永不过期实际包含两层意思：

- 物理不过期，针对热点key不设置过期时间
- 逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建

## 缓存雪崩

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。

## 雪崩解决方案

事前：

1.  均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。
2.  分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。
3.   热点数据缓存永远不过期。
4. 保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。

事中：

1.  互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降
2.  使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。

事后：

- 开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。

  ## 

## 总结

https://blog.csdn.net/a745233700/article/details/88088669 https://segmentfault.com/a/1190000022029639

一般避免以上情况发生我们从三个时间段去分析下：

- 事前：**Redis** 高可用，主从+哨兵，**Redis cluster**，避免全盘崩溃。
- 事中：本地 **ehcache** 缓存 + **Hystrix** 限流+降级，避免 **MySQL** 被打死。
- 事后：**Redis** 持久化 **RDB**+**AOF**，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

# SSM

# 设计模式(单例模式待补全)

## 工厂模式

## 代理模式

## 单例模式

1. ## 饿汉模式

   ~~~java
   public class Hungry{
       private Hungry(){
   	}
       private final static hugry = new Hungry();
       public Hungry getInstance(){
           return hungry;
       }
   }
   ~~~

   

2. ## 懒汉模式

   ~~~java
   //下面这种形式在多线程情况下会出问题
   public class Lazy{
       private Lazy(){
           
       }
       private static lazy;
       public static Lazy getInstance(){
           if(lazy == null){
               lazy = new Lazy();
           }
           return lazy;
       }
   }
   //解决同步问题
   //1.双重检查锁模式  （DCL模式DoubleCheckLock）
   public class Lazy{
           private Lazy(){
           
       }
       private static lazy;
       public static Lazy getInstance(){
           if(lazy == null){
               synchronized(Lazy.class){
                   if(lazy == null){
                       lazy = new Lazy();//不是原子性操作，可能会出问题
                   }
   			}
               
           }
           return lazy;
       }
   }
   //2. DCL模式改进 DCL + Volatile
   public class Lazy{
           private Lazy(){
           
       }
       private volatile static lazy;
       public static Lazy getInstance(){
           if(lazy == null){
               synchronized(Lazy.class){
                   if(lazy == null){
                       lazy = new Lazy();//不是原子性操作，可能会出问题
                   }
   			}
               
           }
           return lazy;
       }
   }
   ~~~

   

3. ## Holder模式（静态内部类）

## ORM 

https://www.jianshu.com/p/ec971e77dd3c

### 是什么

ORM，即Object-Relational Mapping（对象关系映射），它的作用是在关系型数据库和业务实体对象之间作一个映射，这样，我们在具体的操作业务对象的时候，就不需要再去和复杂的SQL语句打交道，只需简单的操作对象的属性和方法。

### 为什么会出现ORM？： 解决不匹配问题

面向对象是从软件工程基本原则(如耦合、聚合、封装)的基础上发展起来的，而关系数据库则是从数学理论发展而来的. 两者之间是不匹配的.而ORM作为项目中间件形式实现数据在不同场景下数据关系映射. 对象关系映射（Object Relational Mapping，简称ORM）<u>是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术</u>.ORM就是这样而来的.

### 优点：

- 第一：隐藏了数据访问细节，“封闭”的通用数据库交互，ORM的核心。
- 第二：ORM使我们构造固化数据结构变得简单易行。

### 缺点：

牺牲性能（解决办法：LazyLoad,Cache ）

## 控制反转IoC

https://www.jianshu.com/p/07af9dbbbc4b Ioc 与依赖注入DI的关系

