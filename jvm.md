#  JVM

# 内存结构

## 公有部分

### Java堆

Java 堆指的是从 JVM 划分出来的一块区域，这块区域专门用于 Java 实例对象的内存分配，几乎所有实例对象都在会这里进行内存的分配。之所以说几乎是因为有特殊情况，有些时候小对象会直接在栈上进行分配，这种现象我们称之为「栈上分配」。

Java 堆还被分为年轻代、老年代两个区域，年轻代还被进一步划分为 Eden 区、From Survivor 0、To Survivor 1 区。

![img](JVM.assets\595137-20190103103329413-247778313.png)

### 方法区（包含了常量池）

方法区指的是存储 Java 类字节码数据的一块区域，它存储了每一个类的结构信息，例如运行时常量池、字段和方法数据、构造方法等。可以看到常量池其实是存放在方法区中的，但《Java 虚拟机规范》将常量池和方法区放在同一个等级上，这点我们知晓即可。

### 为什么”永久代“ 被MetaSpace取代了？

永久代会产生OOM

当时的HotSpot虚拟机设 计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的 工作

使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到内存溢出OOM的问题。永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小。

永久代与堆内存连续，而元空间是使用本地内存。 默认情况下元空间是可以无限使用本地内存的

## 私有部分

- ## 组成： PC + 栈（本地方法栈 虚拟机栈） 

  - ### PC与cpu pc的含义一样，保持下一条指令的地址

  - ### 栈用于管理方法的嵌套调用,栈里面由栈帧组成，每个栈帧对应一个方法调用。实际上就是一个方法调用栈。本地方法栈对应Native 方法（C++写的），虚拟机栈对应JAVA方法。

- ## 栈帧的组成

  - ### 局部变量表：包含方法参数和局部变量。

  - ### 返回地址

### PC寄存器

PC 寄存器，顾名思义 Program Counter 寄存器，指的是保存线程当前正在执行的方法。如果这个方法不是 native 方法，那么 PC 寄存器就保存 Java 虚拟机正在执行的字节码指令地址。如果是 native 方法，那么 PC 寄存器保存的值是 undefined。任意时刻，一条 Java 虚拟机线程只会执行一个方法的代码，而这个被线程执行的方法称为该线程的当前方法，其地址被存在 PC 寄存器中。

### 虚拟机栈

栈帧，本地方法栈、虚拟机栈 的解释：https://www.jianshu.com/p/61d6c4a5e697

![img](JVM.assets\19179872-30ffda0b723b4487.png)

虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信 息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

如果线程请求的栈深度大于虚 拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展[2]，当栈扩 展时无法申请到足够的内存会抛出OutOfMemoryError异常。

### 本地方法栈

本地方法栈（Native Method Stacks）与 Java 虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。

与虚拟机栈类似，只不过，虚拟机栈用于管理Java方法的调用。而本地方法栈则用于管理native方法（例如Thread.start0()）的调用，由于native方法不是用Java实现的，而是由C语言实现的。事实上虚拟机栈和本地方法栈的区域是非常类似的，在Hotspot中直接把本地方法栈和虚拟机栈合二为一，放在了一个区域之中。当然他们本质上的是两个东西。

与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出StackOverflowError和OutOfMemoryError异常。

## 对象的内存布局

- ## 对象在堆中存储布局有三部分：对象头Header 、实例数据Insatance Data、对齐填充 Padding
  - ### Header 包含三部分，数组对象会有数组长度

    ​	MarkWord  + 类型指针 （+ 数组长度）

    ​	MarkWord





# 类加载机制



![image.png](jvm.assets/bVcHO1v)

JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：**加载、验证、准备、解析、初始化、使用、卸载。**

重点：准备和初始化节点

## 准备阶段 

类变量内存分配 和初始化（一般初始化为0值，final 直接初始化为目标值）

## 初始化阶段

<clinit> 由编译器自动生成，由类静态成员赋值语句  以及static 语句块合并产生的。

~~~java
 class test{
     
     <clinit>{ //clinit 包含以下两种成员
         static a;
         static{

         }
 	}
     //不包含静态方法
     static void b(){
	
     }
 }
~~~



编译器**按语句在源文件中出现的顺序**，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生 <clinit>() 方法。 如果类中没有静态语句和静态代码块，那可以不生成 <clinit>方法。	

**对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块）。**

<init> 由（无static 修饰）普通成员赋值语句  以及普通语句块合并产生的。

# java内存管理

## 内容

主要分成两方面：自动分配内存和自动回收内存

## 内存分配原则

- 新对象进入Eden区
- 大对象进入老年代
- 长期存活对象进入老年代

## 内存回收 见GC部分的笔记

# GC



## 垃圾判断算法

垃圾回收，判断某个对象是否是垃圾，有以下算法。

### 引用计数法

记录对象被引用的次数，若为0 则判断为垃圾。

存在循环引用的问题：

A 引用了 B，B 引用了 C，C 引用了 A，它们各自的引用计数都为 1。但是它们三个对象却从未被其他对象引用，只有它们自身互相引用。从垃圾的判断思想来看，它们三个确实是不被其他对象引用的，但是此时它们的引用计数却不为零。这就是引用计数法存在的循环引用问题。

### GC Root Tracing

从 GC Root 出发，所有可达的对象都是存活的对象，而所有不可达的对象都是垃圾。

GC Root 是一组 活跃引用的集合：

- 所有当前被加载的 Java 类
- Java 类的引用类型静态变量
- Java类的运行时常量池里的引用类型常量（String或Class类型）
- VM的一些静态数据结构里指向GC堆里的对象的引用
- 等等

## 垃圾回收算法

垃圾回收算法简单地说有三种算法：标记清除算法、复制算法、标记压缩算法。

### 标记清除算法

分为标记阶段和清除阶段。

标记阶段从GC Root 出发，标记所有可达对象。未标记的对象就认定为垃圾

清除阶段清除未标记的对象

存在碎片问题，清除的对象会使得可分配内存空间不连续，空间不连续会降低效率。

### 标记复制算法

大多都优先采用了这种收集算法去回收新生代

Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍 然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。

### 标记压缩算法

用于收集老年代

#### 移动对象 会产生 Stop-The-World 现象：

移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新 所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行[1]，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机 设计者形象地描述为“Stop The World” [2]。

#### 不考虑移动对象 会影响吞吐量：

完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。内存的访问是用户程序最频繁的操作，甚至都没有之 一，假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。

基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会 更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整 个程序的吞吐量来看，移动对象会更划算。	

### 分代思想

### 分区思想

## 引用类型和GC

1. 强引用  Strong Ref

   指向的对象不会贝回收

   ~~~java
   Object obj = new Object()
   ~~~

   

2. 软引用 Sof Reft

   内存不足时，抛出OOM异常之前进行回收

   ~~~java
   Object obj = new Obj();
   SoftReference<Object> softRef = new SoftReference<Object>(obj);
   obj = null ;//去除强引用
   ~~~

   

3. 弱引用

   每次回收时，只有弱引用指向的对象都会被回收。常用于缓存

4. 虚引用

   完全不会对对象生存时间构成影响。无法通过虚引用来取得一个对象实例。用于跟踪对象回收状态。

# 垃圾回收类型

部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：

-  新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。 
- 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单 独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指， 读者需按上下文区分到底是指老年代的收集还是整堆收集。
-  混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。 

·整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。（**《Java虚拟机规范》对方法区的约束是非常宽松的,提到过可以不要求虚拟机在方法区中实现垃圾收集。方法区的垃圾收集主要回收两部分内容:常量池中废弃的常量和不再使用的类型。**）

# 垃圾回收器

## 串行回收器

## 并行回收器

## CMS回收器 Concurrent Mark Sweep

## G1回收器（分区思想）

