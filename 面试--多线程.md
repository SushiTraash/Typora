# 基本概念

## 进程、线程是什么？

### 进程

- 程序是指令和数据组成，是静态的，是死的。
- 进程是程序在数据集合上的一次运行活动，是动态的，是活的。进程可以看成是程序的一个实例、实体（Entity）。
  - 有的程序可以启动多个进程（记事本）	，有的只能启动一个进程（网易云）。
- 进程是资源分配和调度的kj基本单位。
- 进程是线程的容器，一个进程内可以有多个线程。

### 线程

- 线程是最小的调度单位。
- 线程是轻量级的进程
- 多个线程共享进程的资源
  - JVM中堆和方法区是线程共享的。
  - 程序计数器PC、虚拟机栈、本地方法栈是线程私有的。
  - 注意：Java虚拟机本身就是一个进程，该进程只支持一个Java程序。（在一个JVM进程中，有且只有一个进程；JVM进程本身）

## 线程和进程的区别 参考汤小丹

从调度性、并发性、系统开销、和拥有资源进行比较

- ### 调度

​	进程作为资源拥有的基本单位，线程作为调度和分派的基本单位。

- ### 拥有资源 

​	进程是拥有资源的基本单位，线程基本上不拥有资源，只有一点必不可少的资源。同一进程中的线程可以共享隶属于进程的资源

- ### 并发性

​	同一个进程或不同的进程里的线程都可以并发执行，线程的引入提高了并发性。

- ### 系统开销

​	线程创建、销毁、上下文切换、线程之间的通信开销都比进程的小。
​	进程通信
​		不同主机的进程通信：使用网络
​		同一主机的进程通信：IPC

## 进程和线程的联系

​	进程可以看做是程序的实体，是程序在数据集合上的一次运行活动。
​	进程是线程的容器，为线程的执行提供的基本的环境，线程可以使用从属进程的资源。
​	在JVM的内存模型中，堆和常量池属于jvm进程的，可以被线程共享。而PC、虚拟栈、本地方法栈这些线程必不可少的资源则是线程私有的。为什么这些资源必不可少？保证并发性

- ### Jvm 是在内存中实现的，线程也是jvm创建的，那么java的线程属用户级线程吗？

​	不是的，java中的线程是混合型的，用户级线程和内核级线程混合。

## 并发Concurrent 和并行 Parallel

​	并发是指一段时间内做多件事，但是同一时刻只能做一件事（单核cpu）
​	并行使指同一时刻做多件事。多核cpu中既有并发也有并行。因为核心数远远比不上线程数。

## 同步sync和异步async

​	同步、异步关注的是方法调用。
​	同步方法调用指调用者必须等待调用方法结果返回之后才能继续进行。
​	异步方法调用中调用者不用等到结果返回就能继续进行。

## 临界区

## 阻塞与非阻塞

阻塞指的是多个线程之间的影响，当一个线程占用某个临界区资源，那么其他需要这个临界区资源的线程必须在临界区等待。	

## 并发级别

并发等级从低到高：阻塞、无饥饿、无障碍、无锁、无等待

蓝色是阻塞等级、绿色是非阻塞等级、右边为具体实现（图中无 无饥饿）

<img src="面试--多线程.assets/20180225151057658" alt="并发jib级别" style="zoom:150%;" />

## 线程安全三大性质

原子性、可见性、有序性

### 原子性：

# 线程创建与运行

## 线程创建与运行

1. ### 使用Thread匿名内部类

   ~~~java
   Thread t1 = new Thread(){
       public void run(){
           System.out.println("t1");
       }
   };
   t1.start();//运行线程
   ~~~

   

2. ### 使用Runnable匿名内部类

   ~~~java
   Thread t1 = new Thread(
       new Runnable() {
           @Override
           public void run() {
               //System.out.println("t1");
               log.debug("t1Running");
           }
       }
       ,"t1Name");
   t1.start();
   ~~~

   - ### 使用Lamda简化，实际上和方法2一样。

   ~~~java
   Thread t3 = new Thread(()->log.debug("t3Running"),"t3Name");
   t3.start();
   ~~~

   ### 3.使用FutureTask配合Thread，FutureTask 依赖 Callable（异步调用）

   - FutureTask对Runnable进行了扩展。间接实现Runnable。还继承了Future，Future有get()方法可以返回结果。FutureTask有返回结果

     ~~~java
     FutureTask implements RunnableFuture
     RunnableFuture extends Runnable, Future<V>
     ~~~

   - Callable可以看成进化版的Runnable，Callable里面的Call方法相当于一个有返回值且可以抛出异常的Run方法。

   - Callable  相当于 Runnable 。Thread 相当于  FutureTask 

   ~~~java
   //第三种 FutureTask
   FutureTask<Integer> task = new FutureTask<>(new Callable<Integer>() {
       @Override
       public Integer call() throws Exception {
           log.debug("CallableRunning");
           Thread.sleep(1000);
           return 100;
       }
   });
   Thread t4 = new Thread(task,"t4Name");
   t4.start();
   log.debug("MainRunning");
   log.debug("{}",task.get());//get 方法会使Main线程阻塞，等待结果返回
   ~~~

   

## Thread与Runnable对比

1. Thread是一个类，Runnable是一个接口而且是一个FunctionalInterface，只有run方法。
2. 使用Thread实现，线程喝任务合并在一起，而Runnable使得任务喝线程分离。
3. Runnable 脱离了Thread ，更灵活

## 

# Volatile

## Volatile底层实现

底层使用汇编的Lock指令：Lock做前缀的指令，如 lock addl $0x0, （%esp）。使用CPU缓存一致性协议

### JMM中的工作内存和CPU缓存的关系？

​	JMM中的工作内存其实并不存在，工作内存的底层涵盖了CPU的缓存、寄存器以及其他硬件和编译优化。（Java的拿来主义，JMM中各个线程工作内存并没有具体实现，而是一个抽象概念，具体实现交给硬件）。由此可见，Volatile的一致性是靠Lock指令实现的。

### Lock指令如何保证缓存一致性？

有两步：

- 将当前处理器缓存行写回系统内存。
- 使得其他CPU的对该内存地址的缓存失效。（涉及CPU嗅探机制）

第一步：

- 总线锁：早期的处理器执行Lock前缀指令时，会声言Lock#信号，此时总线会锁住，内存只能被声言了Lock#信号的处理器访问。
- 缓存一致性协议：而现代处理器一般都采用缓存一致性协议，通过锁定缓存来实现缓存一致性。

第二步：处理器嗅探到缓存对应的内存被修改，则使缓存行失效。

### CPU嗅探

处理器的操作会在总线上广播，并且处理器会有嗅探器用于接受其他处理器发出的广播信号。根据接受的信号改变缓存行的姿态

### Intel的缓存一致性协议 --MESI 

缓存具有4种状态：Modified修改 Exclusive独占 Shared共享 Invalid无效。通过嗅探得到的信息，决定状态变化。

嗅探到有第二份缓存要装入另外的处理器时，设置缓存状态为s，当要修改缓存时，锁定缓存：设置缓存状态为M，将缓存写回内存，其他处理器嗅探到之后将对于缓存设置为无效。

详情见：https://cloud.tencent.com/developer/article/1707875

### 总线风暴？